----------   Introduction   ----------


You can find the template for the project here:

https://github.com/Ian-Moffett/HSCorpOS/tree/template


You will need to install qemu which is a 
virtual machine program to run your OS.


----------   Hello, World!   ----------


OSDEV: welcome to your new journey!

You will need to edit gnu-efi/bootloader/main.c

First include efi.h
and also include efilib.h and stdint.h

You will need to create an entry point called efi_main
which will return EFI_STATUS.

This function takes 2 parameters: 

- EFI_HANDLE imageHandle
- EFI_SYSTEM_TABLE* systemTable


Inside the main function you should
initalize the library by calling 
InitalizeLib and passing imageHandle and systemTable.


Use the Print function like so:
Print(L"Any text here\n");
    

And return EFI_SUCESS.

L means long char*.

Now go back to the original folder you were in before and type:
make

Now, type make nfs,
press enter.

Congrats! You have done your first Hello World in your OS!


----------  Loading your first kernel.   ----------


It is time for you to make a kernel!
You will need to load the elf program header
of your compiled kernel into memory
and then jump to it.

How do we do that?
Well first we must load it into memory lol.

You will want to create a function that can load a file.
The function will return EFI_FILE* and it will take

- EFI_FILE* directory
- CHAR16* path
- EFI_HANDLE imageHandle
- EFI_SYSTEM_TABLE* sysTable

Now you want to prepare a variable with type:
EFI_FILE* called fileres.

That will contain the loaded file when we 
finished loading it.

You also want to prepare a variable with type
EFI_LOADED_IMAGE_PROTOCOL* 
which will hold our loaded image.


"But what is a protocol?"

I am glad you asked! 
A protocol serves to enable communication
between separately built modules like drivers.

You will need to get the filesystem that 
the computer booting from.

Use:
sysTable->BootServices->HandleProtocol()
and pass these three things in order:

- imageHandle
- &gEfiLoadedImageProtocolGuid
- (void**)&loadedImage.

Now create a variable of type:

EFI_SIMPLE_FILE_SYSTEM_PROTOCOL*
called filesystem.

Now you need to get the filesystem protocol by calling
sysTable->BootServices->HandleProtocol()
and passing the following in order:

- loadedImage->DeviceHandle
- &gEfiSimpleFileSystemProtocolGuid
- (void**)&filesystem

Now you want to check if the directory is NULL
meaning the person who is calling loadFile is 
requesting the root directory.

If it is then set directory to root by calling
filesystem->OpenVolume(filesystem, &directory)

Don't worry if it is getting too complicated,
I'll explain other functions better.

Now you need to get the status by storing the result
of directory->Open(directory, &fileres, path, EFI_FILE_MODE_READ,
    EFI_FILE_READ_ONLY);

inside a variable of type EFI_STATUS

check if status doesn't equal EFI_SUCESS.
If it doesn't then return NULL.

Now return fileres.


Now in our main function we need to check if the result of loadFile 
(the function we created earlier does not return NULL.

Create a variable of type EFI_FILE* (I will refer to this variable as kernel).
which will be set to loadFile(NULL, L"kernel.elf", imageHandle, sysTable).

If it doens't return NULL then we can continue.

Now we need to get some information about the kernel ELF
by loading it's ELF header.

You will need to include elf.h

Now define a variable of type Elf64_Ehdr
which will be our headers.

Define these variables of these types.

- UINTN (this will the size of the file info)[fileInfoSize]
- EFI_FILE_INFO* (this will be the file info)[fileInfo].

If you wanna know what those square brackets are next to 
the descriptions of the types I wrote, that's just what
I will be refering the variables as.



Now to get the information.


Call kernel->GetInfo() to get fileinfo size.

and pass the following:

- kernel 
- &gEfiFileInfoGuid
- &fileinfoSize
- NULL

Now, we are going to have to allocate some memory for 
the file info.

You can do that by using:

sysTable->BootServices->AllocatePool()

and passing the following:

- EfiLoaderData (don't worry about this).
- fileInfoSize
- (void**)&fileInfo

Now get the size with sizeof(header) and store it in
a varible of type UINTN  [size].

Now read the file info into header with

kernel->Read(kernel, &size, &header).


You will need to paste this helper function somewhere above this function.


int memcmp(const void* aptr, const void* bptr, size_t n) {
	const unsigned char* a = aptr, *b = bptr;
	for (size_t i = 0; i < n; i++) {
		if (a[i] < b[i]) return -1;
		else if (a[i] > b[i]) return 1;
	}
	return 0;
}

Now we will need to verify the ELF header by doing.

if (memcmp(&header.e_ident[EI_MAG0], ELFMAG, SELFMAG) != 0 ||
    header.e_ident[EI_CLASS] != ELFCLASS64 || 
    header.e_type != ET_EXEC || 
    header.e_machine != EM_X86_64 || header.e_version != EV_CURRENT) {

    Print(L"Kernel ELF bad.\n");
} else {
    // Continue from here.
}


Now we need to load the program header.

Create a variable of type Elf64_Phdr* 
which will be our program headers.

Now do 

kernel->SetPosition(kernel, header.e_phoff);

which will set the offset that it will load at in the array of bytes for the next
time we call Read()

Now create a variable of type UINTN which will be 
called progheadersize which will be equal to 
header.phnum * header.e_phentsize.

We need to allocate some memory for the program headers.

Do that by using 

sysTable->BootServices->AllocatePool(EfiLoaderData, progheadersize, (void**)&programheaders)

Now we will read it info memory.

kernel->Read(kernel, &size, programheaders);

Now do this:

for (Elf64_Phdr* phdr = phdrs; (char*)phdr < (char*)phdrs + header.e_phnum * header.e_phentsize; phdr = (Elf64_Phdr*)((char*)phdr + header.e_phentsize)) {
    // Continue in here.
}


Now use a switch statement to check
phdr->p_type

if it is PT_LOAD
then create a scope with '{}'

and create a variable called pages which will be type int and
equal to (phdr->p_memsz + 0x1000 - 1) / 0x1000.
And another one with type Elf64_Addr called segment which
is assigned to phdr->p_paddr.

Now call:

sysTable->BootServices->AllocatePages(AllocateAddress, EfiLoaderData, pages, &segment).

And do:

kernel->SetPosition(kernel, phdr->p_offset);
UINTN size = phdr->p_filesz;
kernel->Read(kernel, &size, (void*)segment);
break;


Now outside of the loop create a function pointer like so:


void(*kernel_entry)() = ((__attribute__((sysv_abi))void(*)())header.e_entry);

And you can call it like so:

kernel_entry();


----------  GOP   ----------

Want to write pixels to the screen?
That's where graphics output protocol or GOP comes in.

Let's get started.

Create a function that returns framebuffer_t* called initGOP()

It will take one parameter:

EFI_SYSTEM_TABLE* sysTable.

framebuffer_t will be defined later.

We will need to get the GOP protocol GUID.

Create a variable called gopGuid with type EFI_GUID and is set
to EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID.
Next, create a variable of type EFI_GRAPHICS_OUTPUT_PROTOCOL* called gop.
Now create a variable of type EFI_STATUS called status
and set it equal to uefi_call_wrapper(BS->LocateProtocol, 3, &gopGuid, NULL, (void**)&gop).
uefi_call_wrapper() is just a little helper function to make calling
certain UEFI functions easier.

do:

if (EFI_ERROR(status)) {
    return NULL;
}

Now just create a struct called framebuffer which will
look like this

typedef struct {
    void* baseAddr;
    size_t bufferSize;
    unsigned int width;
    unsigned int height;
    unsigned int ppsl;      // Pixels per scanline (don't worry about this).
} framebuffer_t;


Now inside your function that prepares GOP create a pointer instance
of the framebuffer_t struct. 

Do this:

sysTable->BootServices->AllocatePool(EfiLoaderData, sizeof(framebuffer_t), (void**)&<framebuffer instance name>);


Set it's baseAddr equal to (void*)gop->Mode->FrameBufferBase.
Set it's bufferSize equal to gop->Mode->FrameBufferSize.
Set it's width equal to gop->Mode->Info->HorizontalResolution.
Set it's height equal to gop->Mode->Info->VerticalResolution.
Set it's ppsl equal to gop->Mode->Info->PixelsPerScanLine.


Now return the framebuffer.


In efi_main create a frame_buffer_t* newBuffer = initalizeGOP(sysTable);


Now you want to return to the normal directory do the following commands:

mkdir kernel/drivers kernel/drivers/impl

Now you want to edit kernel/drivers/FrameBuffer.h


And you want to paste that framebuffer_t struct that you had in the bootloader.

Now include FrameBuffer.h in kernel/src/kernel.c

And make sure _start takes a pointer to framebuffer_t*.


Now in the bootloader change the function pointer from this:

void(*kernel_entry)() = ((__attribute__((sysv_abi))void(*)())kernelHeader.e_entry);

To this:

void(*kernel_entry)(framebuffer_t*) = ((__attribute__((sysv_abi))void(*)(framebuffer_t*))kernelHeader.e_entry);


Now you will need to decode a font file.

Do this:

#define PSF1_MAGIC0 0x00000036
#define PSF1_MAGIC1 0x00000004


typedef struct {
    unsigned char magic[2];
    unsigned char mode;
    unsigned char chsize;
} psf1_header_t;


typedef struct { 
    psf1_header_t* header;
    void* glyphBuffer;
} psf1_font_t;


Now we need to create a function that loads the font.

The function goes like this:

psf1_font_t* load_psf1_font(EFI_FILE* dir, CHAR16* path, EFI_HANDLE imageHandle, EFI_SYSTEM_TABLE* systable) {
    EFI_FILE* font = loadFile(dir, path, imageHandle, systable);

    if (!(font)) {
        return NULL;    // File does not exist.
    }

    psf1_header_t* fontHeader;
    systable->BootServices->AllocatePool(EfiLoaderData, sizeof(psf1_header_t), (void**)&fontHeader);   // Allocate memory for header.
    UINTN size = sizeof(psf1_header_t);
    font->Read(font, &size, fontHeader);

    if (!(fontHeader->magic[0] & PSF1_MAGIC0) || !(fontHeader->magic[1] & PSF1_MAGIC1)) {
        return NULL;   // Format bad.
    }

    UINTN glyphBuffersize = fontHeader->chsize * 256;

    if (fontHeader->mode == 1) {
        glyphBuffersize = fontHeader->chsize * 512;
    }

    void* glyphBuffer;
    font->SetPosition(font, sizeof(psf1_header_t));
    systable->BootServices->AllocatePool(EfiLoaderData, glyphBuffersize, (void**)&glyphBuffer);
    font->Read(font, &glyphBuffersize, glyphBuffer);

    psf1_font_t* fontRes;
    systable->BootServices->AllocatePool(EfiLoaderData, sizeof(psf1_font_t), (void**)&fontRes);

    fontRes->header = fontHeader;
    fontRes->glyphBuffer = glyphBuffer;
    return fontRes;
}


Now in our main create a psf1_font_t* newfont which is equal
to loadFont(NULL, L"zap-light16.psf", imageHandle, sysTable);

Now, check if newfont is NULL (if you made it return NULL when not found) 
if it is then the font
is not found.


Now what you wanna do is make both the function poiunter and the kernel entry function
take a psf1_font_t* argument as the font.

Of course you ware going to have to copy the font stuff over 
to the LFB driver in the kernel.


Now you can write a putstring function with
the helper putchar function.




----------  EFI Memory Map  ----------


We can use the EFI memory map to find out
what memory segments our kernel can use.

We need the EFI memory map first.

Go to gnu-efi/bootloader/main.c
and edit it.


In efi_main create a variable 
of type EFI_MEMORY_DESCRIPTOR*
and is assigned to NULL which will be our map.

And three with UINTN which will be our
mapSize mapKey and descriptorSize.

Also create a variable of type UINT32 called
descriptorVersion (don't worry about this).

EFI_MEMORY_DESCRIPTOR descriptor is just points to a 
struct that gives information like
the number of pages of the memory segment,
the physical address of the section and type.


mapSize is just the size of the map.
descriptor size is size of each descriptor
entry.

And map key is something we don't need to
worry about.

Do:

sysTable->BootServices->GetMemoryMap(&mapSize, map, &mapKey, &descriptorSize, &descriptorVersion);   // Gets size.
sysTable->BootServices->AllocatePool(EfiLoaderData, mapSize, (void**)&map);    // Allocates memory for map.
sysTable->BootServices->GetMemoryMap(&mapSize, map, &mapKey, &descriptorSize, &descriptorVersion);          // Reads map into memory.


Also create a memory_info_t struct that will hold
- EFI_MEMORY_DESCRIPTOR* map;
- UINTN mapSize
- UINTN mapDescriptorSize.


Now do:

memory_info_t mem_info = {
    .map = map,
    .mapSize = mapSize,
    .mapDescriptorSize = descriptorSize
};

And make sure both the function pointer and 
kernel_start take a mem_info struct as an
argument.

Also make sure bootservices is no longer active
so watchdog doesn't think it has crashed
and reboot the system by doing:

sysTable->BootServices->ExitBootServices(imageHandle, mapKey);

Do:

mkdir kernel/src/drivers/memory/ kernel/src/drivers/memory/impl

Create a file inside kernel/src/drivers/memory

called memoryInfo.h

Paste the memory_info struct you made
in the bootloader and also do:

extern const char* const memseg[];

That will be defined in memoryInfo.c

You will need to make a struct called
memdesc_t.

The following will be declared in the struct:

- uint32_t type
- void* physAddr
- void* virtAddr
- uint64_t numPages
- uint64_t attr

You will also need to include stdint.h

Make sure after you paste the memory_info_t 
struct to replace EFI_MEMORY_DESCRIPTOR in 
the struct to memdesc_t.

Also, replace UINTN to uint64_t.

Now, make a const char* array in memoryInfo.c 
that holds the following:

"EfiReservedMemoryType",
"EfiLoaderCode",
"EfiLoaderData",
"EfiBootServicesCode",
"EfiBootServicesData",
"EfiRuntimeServicesCode",
"EfiRuntimeServicesData",
"EfiConventionalMemory",
"EfiUnusableMemory",
"EfiACPIReclaimMemory",
"EfiACPIMemoryNVS",
"EfiMemoryMappedIO",
"EfiMemoryMappedIOPortSpace",
"EfiPalCode",


Now in kernel/src/kernel.c

We need to see each memory map
entry.

We have to find how many entries we have by doing:

uint64_t mMapEntries = (<mem_info_t instance>).mapSize / (<mem_info_t instance>).mapDescriptorSize;

Now we will iterate through each entry:

map IS DEFINED IN mem_info_t struct.

for (int i = 0; i < mMapEntries; ++i) {
    memdesc_t* desc = (memdesc_t*)((uint64_t)(<mem_info_t instance>).mMap + (i * (<mem_info_t>).descriptorSize));
}

Now inside the loop you may print the 
memory sections by including
memoryInfo.h

and doing <your print function>((<name of your const char* array>)[desc->type]);



----------  Global Descriptor Table (GDT)  ----------

Create two folders:

mkdir kernel/src/memory  kernel/src/memory/impl

Now inside kernel/src/memory/ create a file
called GDT.h

You will need to includ stdint.h


Create a packed struct called gdt_descriptor_t.
You can pack it like this:

typedef struct {
} __attribute__((packed)) gdt_descriptor_t;

The GDT descriptor tells the CPU where the GDT is 
and how big it is.

Inside gdt_descriptor_t you will need the following:

- uint16_t size
- uint64_t offset


Now create another packed struct called gdt_entry_t.

That will have the following:

- uint16_t limit0 
- uint16_t base0  
- uint8_t base1
- uint8_t access_byte    // Describes the memory segment.
- uint8_t limit1
- uint8_t flags
- uint8_t base2

Now, we need to create the actual GDT.

Create a packed struct called gdt_t.

It will have the following:

- gdt_entry_t null
- gdt_entry_t kernelcode
- gdt_entry_t kerneldata
- gdt_entry_t usernull
- gdt_entry_t usercode
- gdt_entry_t userdata

And align it with __attribute__((aligned(0x1000))) 

Make sure it also has the packed attribute.

Now do: 

extern gdt_t gdt.
void load_gdt(gdt_descriptor_t* desc);

Now create a file with the path:
kernel/src/memory/impl/GDT.c
Uh oh, scary line number. âœž (don't worry about this lol) 



Create a multiarray with __attribute__((aligned(0x1000)))
of type gdt_t called gdt like this:


__attribute__((aligned(0x1000))) gdt_t gdt = {
    {0, 0, 0, 0x00, 0x00, 0},  // Null descriptor.
    {0, 0, 0, 0x9A, 0xA0, 0},  // Kernel code.
    {0, 0, 0, 0x92, 0xA0, 0},  // Kernel data.
    {0, 0, 0, 0x00, 0x00, 0},  // User null.
    {0, 0, 0, 0x9A, 0xA0, 0},  // User code.
    {0, 0, 0, 0x92, 0xA0, 0}   // User data.
};


We will need to edit kernel/Makefile
so open that file up and add a variable called ASMC
which equals nasm.

Now create a variable under SRC called ASMSRC
which will equal $(call rwildcard,$(SRCDIR),*.asm)

And under OBJS do:
OBJS += $(patsubst $(SRCDIR)/%.asm, $(OBJDIR)/%.asm.o, $(ASMSRC))
Under the labels that look like this:

kernel: $(OBJS) link
$(OBJDIR)/%.o: $(SRCDIR)/%.c
	@mkdir -p $(@D)
	$(CC) $(CFLAGS) -c $^ -o $@

You would want to write the following:

$(OBJDIR)/%.asm.o: $(SRCDIR)/%.asm
	$(ASMC) $^ -felf64 -o $@

Now, you will need to create a file with the path
kernel/src/memory/GDT.asm


Put global loadGdt to make the label global.

Then you will need to tell the assembler to emit 64 bit code
with:

bits 64

Now create a label like this:

loadGdt:
    ; Some code.


Clear interrupts with cli
then load the GDT with:

lgdt [rdi]


Your file should look like this now:

global loadGdt
bits 64

loadGdt:
    cli
    lgdt [rdi]

Make sure to put the kernel data selector in AX
and then set segment registers to the data selector.

Your file should look like this:

global loadGdt
bits 64

loadGdt:
    cli
    lgdt [rdi]
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax

Make sure to get the return address and storing it in RDI.

Return address is first thing on stack frame so you can 
just use pop like this:

pop rdi

Now, move the kernel code selector into RAX
then push it to the stack 

Now create a label after loadGdt label called done

inside that label put a jump instruction to RDI.
Now back inside loadGdt label:

You will have to push the address of the done label to the stack
with the push instruction

then preform a far return with retfq

Your file should look like this now:



global loadGdt
bits 64

loadGdt:
    cli
    lgdt [rdi]
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    pop rdi
    mov rax, 0x08
    push rax
    push done
    retfq

done:
    jmp rdi


Now inside kernel/src/memory/GDT.h

do:

extern void load_gdt(gdt_descriptor_t* desc);

Inside kernel/src/kernel.c

you need to include kernel/src/memory/GDT.h
and create a GDT descriptor like this:

static gdt_descriptor_t gdt_desc = {
    .size = sizeof(gdt) - 1,
    .offset = (uint64_t)&gdt
};


Now load it:

load_gdt(&gdt_desc);



----------  Clearing the screen  ----------


You can clear the screen by using a helper function I made.

First edit kernel/src/drivers/FrameBuffer.h


Now add this declaration:

void clearScreen(canvas_t* canvas, unsigned int color);


Now in the FrameBuffer source file make this definition:

void clearScreen(canvas_t* canvas, unsigned int color) {
    uint64_t bytesPerScanline = canvas->lfb->ppsl * 4;

    for (int vsl = 0; vsl < canvas->lfb->height; ++vsl) {
        uint64_t pixPtrBase = (uint64_t)canvas->lfb->baseAddr + (bytesPerScanline * vsl);
        for (uint32_t* pixelPtr = (uint32_t*)pixPtrBase; pixelPtr < (uint32_t*)(pixPtrBase + bytesPerScanline); ++pixelPtr) {
            *pixelPtr = color;
        }
    }
}


Feel free to use it when you need to!



----------  Interrupt Descriptor Table (IDT)  ----------

Create 2 files with the path:

kernel/src/interrupts/IDT.h
kernel/src/interrupts/impl/IDT.c

in IDT.h you need to do the following:

include stdint.h and create an IDT descriptor.
A IDT descriptor describes an interrupt.

Inside your IDT descriptor struct it will have
the following:

- uint16_t isr_addr_low
- uint16_t selector             // Will be used to determain what segment to switch to during interrupt.
- uint8_t ist : 3
- uint8_t reserved : 5
- uint8_t attr : 4
- uint8_t zero1 : 1
- uint8_t dpl : 2           // Descriptor privellege level.
- uint8_t p : 1             // Present.
- uint16_t isr_addr_middle
- uint32_t isr_addr_high
- uint32_t reserved2


Make sure the struct is packed with
__attribute__((packed))

Now we need the IDTR which will tell the CPU about the IDT.
So create a struct called idtr_t.

MAKE SURE IT IS PACKED

it will contain:

- unsigned short limit
- uint64_t base

Now, when the interrupt fires, an interrupt frame will be setup
to give information about the current CPU state during the interrupt.
Why is this important? Because we have to create an interrupt frame struct.
The struct will be packed and contain the following:

- uint64_t rip          // Instruction pointer.
- uint64_t cs           // Current code segment.
- uint64_t rflags       // used to indicate the status of the computations and to control the CPU operations.
- uint64_t rsp          // Top of stack.
- uint64_t ss           // Stack segment.


Now create two function declarations like this:

void set_idt_entry(unsigned char entry, void* isr, unsigned char flags);
void idt_install()

Now we will do IDT.c


At the top of the file in IDT.c
create two static definitions (static meaning it is only visible in the currentl translation unit).

One will be the actual IDT (just an array of 256 idt descriptor structs).
The other will be the idtr.

Copy the set_idt_entry declaration and put it in the c file and we will
create a body for it.

This is what it will do:

void set_idt_entry(unsigned char entry, void* isr, unsigned char flags) {
    uint64_t addr = (uint64_t)isr;
    idt[entry].isr_addr_low = addr & 0xFFFF;                         // Grabs the low bits.
    idt[entry].isr_addr_middle = (addr & 0xFFFF0000) >> 16;          // Grabs the middle bits.
    idt[entry].isr_addr_high = (addr & 0xFFFFFFFF00000000) >> 32;    // Grabs the higher bits.
    idt[entry].dpl = 0;                                              // Ring 0 for now, we may have to change this later.
    idt[entry].p = 1;                                                // It is present.
    idt[entry].attr = flags;                                        
    idt[entry].selector = 0x08;
    idt[entry].reserved = 0x0;
    idt[entry].reserved2 = 0x0;
}


Now copy the idt_install declaration and add a body which will go like this:

void idt_install() {
    // The static idtr instance you made and IDT is the static array of idt_descriptors.
    idtr.limit = (unsigned char)(sizeof(idt)); 
    idtr.base = (uint64_t)&idt;
    __asm__ __volatile__("lidt %0" : : "memory" (idtr));        // Loads IDTR.
}

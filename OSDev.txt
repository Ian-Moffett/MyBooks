----------   Introduction   ----------


You can find the template for the project here:

https://github.com/Ian-Moffett/HSCorpOS/tree/template


You will need to install qemu which is a 
virtual machine program to run your OS.


----------   Hello, World!   ----------


OSDEV: welcome to your new journey!

You will need to edit gnu-efi/bootloader/main.c

First include efi.h
and also include efilib.h and stdint.h

You will need to create an entry point called efi_main
which will return EFI_STATUS.

This function takes 2 parameters: 

- EFI_HANDLE imageHandle
- EFI_SYSTEM_TABLE* systemTable


Inside the main function you should
initalize the library by calling 
InitalizeLib and passing imageHandle and systemTable.


Use the Print function like so:
Print(L"Any text here\n");
    

And return EFI_SUCESS.

L means long char*.

Now go back to the original folder you were in before and type:
make

Now, type make nfs,
press enter.

Congrats! You have done your first Hello World in your OS!


----------  Loading your first kernel.   ----------


It is time for you to make a kernel!
You will need to load the elf program header
of your compiled kernel into memory
and then jump to it.

How do we do that?
Well first we must load it into memory lol.

You will want to create a function that can load a file.
The function will return EFI_FILE* and it will take

- EFI_FILE* directory
- CHAR16* path
- EFI_HANDLE imageHandle
- EFI_SYSTEM_TABLE* sysTable

Now you want to prepare a variable with type:
EFI_FILE* called fileres.

That will contain the loaded file when we 
finished loading it.

You also want to prepare a variable with type
EFI_LOADED_IMAGE_PROTOCOL* 
which will hold our loaded image.


"But what is a protocol?"

I am glad you asked! 
A protocol serves to enable communication
between separately built modules like drivers.

You will need to get the filesystem that 
the computer booting from.

Use:
sysTable->BootServices->HandleProtocol()
and pass these three things in order:

- imageHandle
- &gEfiLoadedImageProtocolGuid
- (void**)&loadedImage.

Now create a variable of type:

EFI_SIMPLE_FILE_SYSTEM_PROTOCOL*
called filesystem.

Now you need to get the filesystem protocol by calling
sysTable->BootServices->HandleProtocol()
and passing the following in order:

- loadedImage->DeviceHandle
- &gEfiSimpleFileSystemProtocolGuid
- (void**)&filesystem

Now you want to check if the directory is NULL
meaning the person who is calling loadFile is 
requesting the root directory.

If it is then set directory to root by calling
filesystem->OpenVolume(filesystem, &directory)

Don't worry if it is getting too complicated,
I'll explain other functions better.

Now you need to get the status by storing the result
of directory->Open(directory, &fileres, path, EFI_FILE_MODE_READ,
    EFI_FILE_READ_ONLY);

inside a variable of type EFI_STATUS

check if status doesn't equal EFI_SUCESS.
If it doesn't then return NULL.

Now return fileres.


Now in our main function we need to check if the result of loadFile 
(the function we created earlier does not return NULL.

Create a variable of type EFI_FILE* (I will refer to this variable as kernel).
which will be set to loadFile(NULL, L"kernel.elf", imageHandle, sysTable).

If it doens't return NULL then we can continue.

Now we need to get some information about the kernel ELF
by loading it's ELF header.

You will need to include elf.h

Now define a variable of type Elf64_Ehdr
which will be our headers.

Define these variables of these types.

- UINTN (this will the size of the file info)[fileInfoSize]
- EFI_FILE_INFO* (this will be the file info)[fileInfo].

If you wanna know what those square brackets are next to 
the descriptions of the types I wrote, that's just what
I will be refering the variables as.



Now to get the information.


Call kernel->GetInfo() to get fileinfo size.

and pass the following:

- kernel 
- &gEfiFileInfoGuid
- &fileinfoSize
- NULL

Now, we are going to have to allocate some memory for 
the file info.

You can do that by using:

sysTable->BootServices->AllocatePool()

and passing the following:

- EfiLoaderData (don't worry about this).
- fileInfoSize
- (void**)&fileInfo

Now get the size with sizeof(header) and store it in
a varible of type UINTN  [size].

Now read the file info into header with

kernel->Read(kernel, &size, &header).


You will need to paste this helper function somewhere above this function.


int memcmp(const void* aptr, const void* bptr, size_t n) {
	const unsigned char* a = aptr, *b = bptr;
	for (size_t i = 0; i < n; i++) {
		if (a[i] < b[i]) return -1;
		else if (a[i] > b[i]) return 1;
	}
	return 0;
}

Now we will need to verify the ELF header by doing.

if (memcmp(&header.e_ident[EI_MAG0], ELFMAG, SELFMAG) != 0 ||
    header.e_ident[EI_CLASS] != ELFCLASS64 || 
    header.e_type != ET_EXEC || 
    header.e_machine != EM_X86_64 || header.e_version != EV_CURRENT) {

    Print(L"Kernel ELF bad.\n");
} else {
    // Continue from here.
}


Now we need to load the program header.

Create a variable of type Elf64_Phdr* 
which will be our program headers.

Now do 

kernel->SetPosition(kernel, header.e_phoff);

which will set the offset that it will load at in the array of bytes for the next
time we call Read()

Now create a variable of type UINTN which will be 
called progheadersize which will be equal to 
header.phnum * header.e_phentsize.

We need to allocate some memory for the program headers.

Do that by using 

sysTable->BootServices->AllocatePool(EfiLoaderData, progheadersize, (void**)&programheaders)

Now we will read it info memory.

kernel->Read(kernel, &size, programheaders);

Now do this:

for (Elf64_Phdr* phdr = phdrs; (char*)phdr < (char*)phdrs + header.e_phnum * header.e_phentsize; phdr = (Elf64_Phdr*)((char*)phdr + header.e_phentsize)) {
    // Continue in here.
}


Now use a switch statement to check
phdr->p_type

if it is PT_LOAD
then create a scope with '{}'

and create a variable called pages which will be type int and
equal to (phdr->p_memsz + 0x1000 - 1) / 0x1000.
And another one with type Elf64_Addr called segment which
is assigned to phdr->p_paddr.

Now call:

sysTable->BootServices->AllocatePages(AllocateAddress, EfiLoaderData, pages, &segment).

And do:

kernel->SetPosition(kernel, phdr->p_offset);
UINTN size = phdr->p_filesz;
kernel->Read(kernel, &size, (void*)segment);
break;


Now outside of the loop create a function pointer like so:


void(*kernel_entry)() = ((__attribute__((sysv_abi))void(*)())header.e_entry);

And you can call it like so:

kernel_entry();





----------  GOP   ----------

Want to write pixels to the screen?
That's where graphics output protocol or GOP comes in.

Let's get started.

Create a function that returns framebuffer_t* called initGOP()

It will take one parameter:

EFI_SYSTEM_TABLE* sysTable.

framebuffer_t will be defined later.

We will need to get the GOP protocol GUID.

Create a variable called gopGuid with type EFI_GUID and is set
to EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID.
Next, create a variable of type EFI_GRAPHICS_OUTPUT_PROTOCOL* called gop.
Now create a variable of type EFI_STATUS called status
and set it equal to uefi_call_wrapper(BS->LocateProtocol, 3, &gopGuid, NULL, (void**)&gop).
uefi_call_wrapper() is just a little helper function to make calling
certain UEFI functions easier.

do:

if (EFI_ERROR(status)) {
    return NULL;
}

Now just create a struct called framebuffer which will
look like this

typedef struct {
    void* baseAddr;
    size_t bufferSize;
    unsigned int width;
    unsigned int height;
    unsigned int ppsl;      // Pixels per scanline (don't worry about this).
} framebuffer_t;


Now inside your function that prepares GOP create a pointer instance
of the framebuffer_t struct. 

Do this:

sysTable->BootServices->AllocatePool(EfiLoaderData, sizeof(framebuffer_t), (void**)&<framebuffer instance name>);


Set it's baseAddr equal to (void*)gop->Mode->FrameBufferBase.
Set it's bufferSize equal to gop->Mode->FrameBufferSize.
Set it's width equal to gop->Mode->Info->HorizontalResolution.
Set it's height equal to gop->Mode->Info->VerticalResolution.
Set it's ppsl equal to gop->Mode->Info->PixelsPerScanLine.


Now return the framebuffer.


In efi_main create a frame_buffer_t* newBuffer = initalizeGOP(sysTable);
